<#
    .SYNOPSIS
    Enables Azure Automation to run scripts on VMs in a private network that may not have the Azure VM 
    Agent installed -- even on-premises VMs.
    
    .DESCRIPTION
    This runbook requires the user to have an Azure VM (with the VM Agent installed) which 
    belongs to a network. The VM will be used to execute a script block on other computers in its 
    network (by joining an Azure Virtual Network to an on-premises network, this will enable connectivity
    to on-premises from Azure Automation). The VM will be referred to below as the "Proxy VM".
    The Proxy VM must also have a .pfx certificat installed, whose corresponding .cer is available 
    as an Asset in Azure Automation. The certificate will be used to encrypt/decrypt the credentials 
    necessary to make remote calls.
    Finally, the user must provide an Azure Storage Account in which the runbook will store a generated
    script. 
    For more details and instructions, see the Azure Automation blog:
    http://azure.microsoft.com/blog/tag/azure-automation/

    .PARAMETER ProxyVmName
    The name of the Proxy VM. This is an Azure VM which has the VM Agent installed, and is on the same 
    network as the TargetComputers. It will use PowerShell Remoting to execute the given script block on
    the target computers.
    In order for this VM to communicate with Azure, the Custom Script Extension will be enabled on it.
        
    .PARAMETER ProxyServiceName
    The name of the Azure Cloud Service that contains the Proxy VM.
        
    .PARAMETER ScriptBlock
    The PowerShell script block (given as a string) that will be run on the targeted computers.
    
    .PARAMETER TargetComputers
    A list of computers on which the Proxy VM will run the given ScriptBlock.

    .PARAMETER RunAsCredential
    The Proxy VM will run the ScriptBlock on the TargetComputers using this credential.
         
    .PARAMETER CertificateAssetName
    The name of the certificate asset in Azure Automtaion to use for credential encryption.
    The asset should be a .cer file, and will be used to encrypt the RunAsCredential's password.
    The .pfx file for this certificate must be present on the Proxy VM (in the Cert:\LocalMachine\My 
    directory) and will be used to decrypt the password when the script block is run.
               
    .PARAMETER StorageAccountName
    The name of the Azure Storage Account used to store the PowerShell script generated by this workflow.

    .PARAMETER ContainerName
    The name of the Azure Storage Container used to store the PowerShell script generated by this workflow.
    Defaults to "invoke-command-via-proxy", and creates this container if it doesn't already exist.
    
    .PARAMETER AzureOrgIdCredential
    The PSCredential object used to authenticate to Azure AD.
    For more information on this method of authentication, see our blog post on the subject:
    http://azure.microsoft.com/blog/2014/08/27/azure-automation-authenticating-to-azure-using-azure-active-directory/
    
    .PARAMETER AzureSubscriptionName
    The name of the Azure Subscription against which the workflow will be run.

    .PARAMETER PollingIntervalInSeconds
    The time, in seconds, the workflow will wait between each check for results on the Proxy VM.
    Defaults to 10 seconds.

    .PARAMETER TimeoutLimitInSeconds
    The time, in seconds, after which the workflow will cease checking the Proxy VM for results.
    Defaults to 180 seconds.
    
    .PARAMETER WaitForCompletion
    A boolean value. Defaults to $true, causing the runbook to wait for the script block to complete and 
    return its output.

    .PARAMETER SerializeOutput
    A boolean value. When set to $false, the script block's output will be returned in plain text. 
    Defaults to $true, in which case the output will come back as a PowerShell Object.
    The Custom Script Extension's output buffer is limited to 4096 characters. So, setting this 
    parameter to $false will enable you to see more return data, with the trade-off of having to 
    handle string output.
    
    .OUTPUT
    Returns the output objects generated by the script block (or a raw string, if the SerializeOutput 
    parameter is set to $false). If the script block is run on multiple computers, an array of the 
    output objects from each computer will be returned.
     
    .EXAMPLES
    $Results = Invoke-CommandViaProxy `
        -ProxyVmName VM01 `
        -ProxyServiceName VM01 `
        -ScriptBlock "{ 'Hello, my name is '; `$env:COMPUTERNAME}" `
        -TargetComputers VM02,VM03 `
        -RunAsCredential $NetworkCred `
        -CertificateAssetName "MyProxyVmCert" `
        -AzureOrgIdCredential $OrgCred `
        -AzureSubscriptionName $SubscriptionName `
        -StorageAccountName $StorageAccountName
    
    Invoke-CommandViaProxy `
        -ProxyVmName VM01 `
        -ProxyServiceName VM01 `
        -ScriptBlock "{ 'Hello, my name is '; `$env:COMPUTERNAME}" `
        -TargetComputers VM02,VM03 `
        -RunAsCredential $NetworkCred `
        -CertificateAssetName "MyProxyVmCert" `
        -AzureOrgIdCredential $OrgCred `
        -AzureSubscriptionName $SubscriptionName `
        -StorageAccountName $StorageAccountName `
        -ContainerName $StorageContainerName `
        -PollingIntervalInSeconds 5 `
        -TimeoutLimitInSeconds 120 `
        -SerializeOutput $False `
        -WaitForCompletion $False
  
    .NOTES
    AUTHOR: System Center Automation Team
    LASTEDIT: Jan 27, 2015
#>
workflow Invoke-CommandViaProxy
{
    Param (
        [Parameter(Mandatory=$True)]
        [PSCredential]
        $AzureOrgIdCredential,

        [Parameter(Mandatory=$True)]
        [String]
        $AzureSubscriptionName,

        [Parameter(Mandatory=$True)]
        [String]
        $StorageAccountName,

        [Parameter(Mandatory=$True)]
        [String]
        $ProxyVmName,

        [Parameter(Mandatory=$True)]
        [String]
        $ProxyServiceName,

        [Parameter(Mandatory=$True)]
        [String]
        $ScriptBlock,

        [Parameter(Mandatory=$True)]
        [String[]]
        $TargetComputers,

        [Parameter(Mandatory=$True)]
        [PSCredential]
        $RunAsCredential,

        [Parameter(Mandatory=$False)]
        [String]
        $ContainerName = "invoke-command-via-proxy",

        [Parameter(Mandatory=$True)]
        [String]
        $CertificateAssetName,

        [Parameter(Mandatory=$False)]
        [int]$PollingIntervalInSeconds = 10,

        [Parameter(Mandatory=$False)]
        [int]$TimeoutLimitInSeconds = 180,

        [Parameter(Mandatory=$False)]
        [bool]$WaitForCompletion = $True,

        [Parameter(Mandatory=$False)]
        [bool]$SerializeOutput = $True
    )
    #Authenticate to Azure
    Configure-Azure -Credential $AzureOrgIdCredential -SubscriptionName $AzureSubscriptionName -CurrentStorageAccountName $StorageAccountName
    $LastCseUpdate = inlinescript {
        $vm = Get-AzureVM -ServiceName $using:ProxyServiceName -Name $using:ProxyVmName
        $status = ($vm.ResourceExtensionStatusList.ExtensionSettingStatus | where { $_.Name -eq "CustomScriptHandler"})
        $status.TimestampUtc
    }
    if (!(Get-AzureStorageContainer -Container $ContainerName -ErrorAction SilentlyContinue)) {
        New-AzureStorageContainer -Name $ContainerName | Write-Verbose
    }
    $Cert = Get-AutomationCertificate -Name $CertificateAssetName
    $CertThumbprint = $Cert.Thumbprint
    #Use a private function to create a PowerShell script and put it on disk. 
    #This script will later be uploaded to Azure Storage and ultimately run by the Proxy VM.
    $FilePath = Generate-PSScriptFile -ScriptBlock $ScriptBlock -TargetComputers $TargetComputers -RunAsCredential $RunAsCredential -CertThumbprint $CertThumbprint -SerializeOutput $SerializeOutput
    $FileName = Split-Path -Path $FilePath -Leaf
    $UserName = $RunAsCredential.UserName.ToString()
    #Use a private function to encrypt the Credential's password using the given Certificate 
    $EncryptedPwd = Encrypt-Password -CertThumbprint $CertThumbprint -Credential $RunAsCredential
    $ArgumentList = "$UserName $EncryptedPwd $CertThumbprint"
    Set-AzureStorageBlobContent -Container $ContainerName -Blob $FileName -File $FilePath -Force | Write-Verbose
    #Use a private helper function that configures the Proxy VM to start looking for a script to run
    Set-AzureVMCustomScriptExtensionHelper -VMName $ProxyVmName -ServiceName $ProxyServiceName -ContainerName $ContainerName -FileName $FileName -Run $FileName -Argument $ArgumentList
    if($WaitForCompletion) {
        #Use a private function to poll the Proxy VM for results
        $results = Get-Results -VMName $ProxyVmName -ServiceName $ProxyServiceName -LastCseUpdate $LastCseUpdate -PollInterval $PollingIntervalInSeconds -Timeout $TimeoutLimitInSeconds -SerializeOutput $SerializeOutput
        #Use a private function to remove the script from Azure Storage.
        #Note that this cleanup cannot happen automatically if the runbook doesn't wait for results.
        Clean-Up -ContainerName $ContainerName -ScriptFileName $FileName
        Write-Output $results
    }
    <#
      BEGIN private functions
    #>
    <#
      Sets up the Azure environment necessary to execute the workflow. Throws an exception if any of
        its actions fail, since the rest of the runbook would fail as a result.
    #>
    Function Configure-Azure {
        Param(
            [PSCredential]$Credential,
            [String]$SubscriptionName,
            [String]$CurrentStorageAccountName
        )
        Add-AzureAccount -Credential $Credential -ErrorAction Stop | Write-Verbose
        Select-AzureSubscription -SubscriptionName $SubscriptionName -ErrorAction Stop | Write-Verbose
        Set-AzureSubscription -SubscriptionName $SubscriptionName -CurrentStorageAccountName $CurrentStorageAccountName -ErrorAction Stop | Write-Verbose
    }
    <#
      Configures the Custom Script Extension on the Proxy VM, and updates the Proxy VM accordingly.
        If the VM is already being updated by some other process, this function will wait for the
        given PollInterval (default: 30 seconds) and then re-attempt the update. It will continue to do so
        until the given Timeout (default: 120 seconds) is reached.
    #>
    Function Set-AzureVMCustomScriptExtensionHelper {
        Param(
            [String]$VMName,
            [String]$ServiceName,
            [String]$ContainerName,
            [String]$FileName,
            [String]$Run,
            [String]$Argument,
            [int]$PollInterval=30,
            [int]$Timeout=120
        )
        $timeElapsed = 0
        while($timeElapsed -lt $Timeout) {
            try {
                if($Argument) {
                    Get-AzureVM -Name $VMName -ServiceName $ServiceName | 
                        Set-AzureVMCustomScriptExtension -ContainerName $ContainerName -FileName $FileName -Run $FileName -Argument $Argument | 
                        Update-AzureVM -ErrorAction Stop | Write-Verbose
                } else {
                    Get-AzureVM -Name $VMName -ServiceName $ServiceName |
                        Set-AzureVMCustomScriptExtension -ContainerName $ContainerName -FileName $FileName -Run $FileName | 
                        Update-AzureVM -ErrorAction Stop | Write-Verbose
                }
                Return
            } catch {
                if($_.Exception -match 'ConflictError') {
                    Write-Verbose "Received a ConflictError when trying to update the Azure VM. Will retry in $PollInterval seconds."
                    $timeElapsed += $PollInterval
                    Sleep $PollInterval
                } else {
                    Write-Error $_
                    Return
                }
            }
        }
        Throw "Could not configure the Custom Script Extension on the Proxy VM within the time limit of $Timeout seconds."
    }
    <#
      Generates a PowerShell script file that invokes the given script block
        on the target computers.
      Returns the full path to the generated script file.
    #>
    Function Generate-PSScriptFile
    {
        Param(
            [String]$ScriptBlockString,
            [String[]]$TargetComputers,
            [PSCredential]$RunAsCredential,
            [String]$CertThumbprint,
            [Bool]$SerializeOutput
        )
        $ScriptBlock = [ScriptBlock]::Create($ScriptBlockString)
    
        $Guid = ([GUID]::NewGuid()).Guid
        $ScriptFileName = "CSE-invoke-script-" + $Guid + ".ps1"
        $OutputFileName = $ScriptFileName + ".output.xml"
        $ErrorFileName = $ScriptFileName + ".err"
        $ScriptFilePath = Join-Path $env:temp $ScriptFileName
    
        $PowerShellScript = "Param ([String] `$UserName, [String] `$EncryptedPwd, [String] `$CertThumbprint)`r`n"
        if($RunAsCredential) {
            $PowerShellScript += @"
try {`r`n
    `$cert = Get-Item -Path Cert:\LocalMachine\My\`$CertThumbprint -ErrorAction Stop`r`n
} catch {`r`n
    Throw "Could not decrypt the credentials provided to the Proxy VM. The required certificate with the given thumbprint could not be found. Full error: `$_"`r`n
}`r`n
try {`r`n
    `$encrypted = [Convert]::FromBase64String(`$EncryptedPwd)`r`n
    `$bytes = `$cert.PrivateKey.Decrypt(`$encrypted,`$true)`r`n
    `$password = [Text.Encoding]::UTF8.GetString(`$bytes)`r`n
    `$securepassword = ConvertTo-SecureString -AsPlainText -Force -String `$password`r`n
    `$RunAsCredential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList `$UserName,`$securepassword`r`n
} catch {`r`n
    Throw "Could not decrypt the credentials provided to the Proxy VM. Error: `$_"`r`n
}`r`n
"@
    }
        if(!$TargetComputers) {
            $PowerShellScript += "`r`n`$Result = Invoke-Command -ScriptBlock $ScriptBlock`r`n"
        } else {
            $targetComputerStr = ""
            foreach($computer in $TargetComputers) {
                $targetComputerStr += ",$computer"
            }
            $targetComputerStr = $targetComputerStr.Substring(1)
            $PowerShellScript += "`r`n`$Result = Invoke-Command -ScriptBlock $ScriptBlock -ComputerName $targetComputerStr -Credential `$RunAsCredential`r`n"
        }
        if($SerializeOutput) {
        $PowerShellScript += @"
Write-Output ([System.Management.Automation.PSSerializer]::Serialize(`$Result))
"@
        } else {
            $PowerShellScript += "`$Result"
        }
        Write-Verbose "Creating PowerShell Script at $ScriptFilePath"
        Set-Content -Path $ScriptFilePath -Value $PowerShellScript
        Write-Output $ScriptFilePath
    }
    <#
      Extracts the password from the given Credential and encrypts it using the certificate specified
        by the given thumbprint, which must be in the Cert:\LocalMachine\Root or Cert:\LocalMachine\My
        (also called Personal) store.
      Returns the encrypted password.
    #>
    Function Encrypt-Password
    {
        Param(
            [String]$CertThumbprint,
            [PSCredential]$Credential
        )
        $CertPath = $null
        if (Test-Path Cert:\LocalMachine\Root\$CertThumbprint) {
            $CertPath = "Cert:\LocalMachine\Root\$CertThumbprint"
        } elseif (Test-Path Cert:\LocalMachine\My\$CertThumbprint) {
            $CertPath = "Cert:\LocalMachine\My\$CertThumbprint"
        } else {
            Throw "Could not encrypt credentials: certificate with thumbprint $CertThumbprint was not found on $env:ComputerName"
        }
        $password = $Credential.GetNetworkCredential().Password
        $cert = Get-Item -Path $CertPath
        $passwordBytes = [Text.Encoding]::UTF8.GetBytes($password)
        $encryptedBytes = $cert.PublicKey.Key.Encrypt($passwordBytes, $True)
        Write-Output ([Convert]::ToBase64String($encryptedBytes))
    }
    <#
      Repeatedly polls (every PollInterval seconds) the Custom Script Extension for its results, and returns
        them when they are found. Gives up when Timeout is reached.
    #>
    Function Get-Results
    {
        Param (
            [String]$VMName,
            [String]$ServiceName,
            [DateTime]$LastCseUpdate,
            [int]$PollInterval,
            [int]$Timeout,
            [Bool]$SerializeOutput
        )
        $elapsedTime = 0
        while($elapsedTime -lt $Timeout) {
            $vm = Get-AzureVM -ServiceName $ServiceName -Name $VMName
            $status = ($vm.ResourceExtensionStatusList.ExtensionSettingStatus | where { $_.Name -eq "CustomScriptHandler"})
            if($status.TimestampUtc -gt $LastCseUpdate) {
                Write-Verbose "Results found"
                if($status.Status -eq "Error") {
                    $msg = $status.FormattedMessage.Message
                    Write-Error "The Custom Script Extension couldn't execute the script. Returned message: $msg"
                } else {
                    $errorMsg = ($status.SubStatusList | where { $_.Name -eq "StdErr"}).FormattedMessage.Message
                    $outputMsg = ($status.SubStatusList | where { $_.Name -eq "StdOut"}).FormattedMessage.Message
                    if($errorMsg) {
                        Write-Error $errorMsg.Replace("\n", "`r`n")
                    }
                    if($outputMsg -and $SerializeOutput) {
                        try {
                            Write-Output ([System.Management.Automation.PSSerializer]::Deserialize($outputMsg.Replace("\n", "`r`n")))
                        } catch {
                            $errorMsg = "The output object couldn't be deserialized. It may be too large for the output buffer "
                            $errorMsg += "(the Custom Script Extension can only store 4096 characters of output). "
                            $errorMsg += "Try re-running with the -SerializeOutput parameter set to `$false to get the output as a string instead."
                            Write-Error $errorMsg
                            Write-Error "Exception: $_"
                        }
                    } elseif ($outputMsg -and !$SerializeOutput) {
                        Write-Output $outputMsg
                    }
                }
                Return
            } else {
                Write-Verbose "Awaiting output from VM $VMName, have waited $elapsedTime seconds"
            }
            Sleep $PollInterval
            $elapsedTime += $PollInterval
        }
        Throw "Waiting for results timed out: could not find output before reaching the given limit of $Timeout seconds"
    }
    <#
      Removes the generated script from the given container, as well as any of its associated files
        (output, etc.)
    #>
    Function Clean-Up
    {
        Param(
            [String]$ContainerName,
            [String]$ScriptFileName
        )
        Get-AzureStorageBlob -Container $ContainerName | where { $_.Name.Contains($ScriptFileName) } | Remove-AzureStorageBlob | Write-Verbose
    }
}